# Issue certificates

trigger: none

schedules:
  - cron: "0 0 * * *"
    displayName: Daily certificate issue or renew
    always: true
    branches:
      include:
        - master

variables:
  skipComponentGovernanceDetection: true
  azureSubscription: mattwhiteazuresub
  letsEncryptEnvironment: LE_STAGE
  symmetricKeyName: leconfigsecretwrapped

stages:
- stage: Certificate
  displayName: Certificate
  jobs:
  - job: cert
    displayName: Issue or renew certificate
    pool:
      vmImage: 'ubuntu-latest'
    steps:
    - task: AzureKeyVault@1
      displayName: Get secret
      inputs:
        azureSubscription: $(azureSubscription)
        KeyVaultName: $(keyvaultName)
        SecretsFilter: $(symmetricKeyName)

    - task: AzureCLI@1
      displayName: az cli generate vault token
      inputs:
        scriptLocation: inlineScript
        inlineScript: "echo '##vso[task.setvariable variable=vaultToken;issecret=true]'`az account get-access-token --resource 'https://vault.azure.net' --query accessToken --output tsv`"
        azureSubscription: $(azureSubscription)
        failOnStandardError: true

    - script: |
        jq -n --arg data "$(leconfigsecretwrapped)" '. += { alg: "RSA-OAEP" } | .value += $data' > req.json
        HEADER="Authorization: Bearer $(vaultToken)"
        URL="https://$(keyvaultName).vault.azure.net/keys/$(asymmetricKeyName)/$(asmmetricKeyVersion)/unwrapkey?api-version=7.0"
        SYMKEY=`curl --header "$HEADER" --header "Content-Type: application/json" --data "@req.json" -X POST $URL | jq -r .value`
        rm -f req.json
        echo "##vso[task.setvariable variable=symmetricKey;issecret=true]$SYMKEY"
      displayName: Unwrap key
      env:
        ASYMMETRICKEYNAME: $(asymmetricKeyName)
        ASYMMETRICKEYVERSION: $(asymmetricKeyVersion)
        KEYVAULTNAME: $(keyvaultName)
        SYMMETRICKEYNAME: $(symmetricKeyName)
        LECONFIGSECRETWRAPPED: $(leconfigsecretwrapped)

    - task: AzureCLI@1
      displayName: Download & extract config
      inputs:
        scriptLocation: inlineScript
        inlineScript: |
          EXISTS=`az storage blob exists --name acme.tar.gz.gpg --container config --account-name $(leconfigstorageaccount) --query exists --output tsv`
          if [ "$EXISTS" -eq 'false' ]; then
            echo "WARNING: ACME config backup not found. Creating..."
            mkdir -v Posh-ACME
            exit 0
          fi
          az storage blob download --account-name $(leconfigstorageaccount) --container config --name acme.tar.gz.gpg
          gpg --decrypt --symmetric --pinentry-mode loopback --passphrase $PASSPHRASE acme.tar.gz.gpg
          tar xvzf acme.tar.gz
        azureSubscription: $(AzureSubscription)
        workingDirectory: $(Agent.TempDirectory)
      env:
        PASSPHRASE: $(symmetricKey)

    - task: PowerShell@2
      displayName: Install Posh-ACME
      inputs:
        targetType: inline
        script: Install-Module Posh-ACME -Force -Verbose -Scope CurrentUser
        failOnStderr: true

    - task: AzureCLI@1
      displayName: az cli generate azure token
      inputs:
        scriptLocation: inlineScript
        inlineScript: "echo '##vso[task.setvariable variable=azureToken;issecret=true]'`az account get-access-token --query accessToken --output tsv`"
        azureSubscription: $(azureSubscription)
        failOnStandardError: true

    - task: PowerShell@2
      displayName: Posh-ACME
      inputs:
        targetType: filePath
        filePath: certbot/issuecert.ps1
        failOnStderr: true
        workingDirectory: $(System.DefaultWorkingDirectory)/certbot
      env:
        POSHACME_HOME: $(Agent.TempDirectory)/Posh-ACME
        AZURE_TOKEN: $(azureToken)
        LE_ENV: $(letsEncryptEnvironment)
        AZURE_SUBSCRIPTION_ID: $(azureSubscriptionId)

    - task: CmdLine@2
      displayName: OpenSSL generate PFX
      inputs:
        workingDirectory: $(Agent.TempDirectory)/Posh-ACME
        failOnStderr: true
        script: |
          cd `cat current-server.txt | cut -d'/' -f 3`
          cd `cat current-account.txt`
          cd `cat current-order.txt`
          openssl pkcs12 -export -keypbe NONE -certpbe NONE -inkey cert.key -in cert.cer -certfile chain.cer -out $AGENT_TEMP/cert-nopasswd.pfx -passout pass:
      env:
        AGENT_TEMP: $(Agent.TempDirectory)

    - task: AzureCLI@1
      name: certstorekv
      displayName: Store certificate in Key Vault
      inputs:
        azureSubscription: $(azureSubscription)
        scriptLocation: inlineScript
        inlineScript: |
          CERTID=`az keyvault certificate import --vault-name $(keyVaultName) \
                                        --name mattwhiteblog \
                                        --file $(Agent.TempDirectory)/cert-nopasswd.pfx \
                                        --query id --output tsv`
          echo "New cert version below:"
          echo "##vso[task.setvariable variable=certificateVersion;isSecret=true]$CERTID"
        
    - task: AzureCLI@1
      displayName: Compress & store config
      inputs:
        scriptLocation: inlineScript
        inlineScript: |
          tar cvzf acme.tar.gz Posh-ACME
          gpg --symmetric --pinentry-mode loopback --passphrase $PASSPHRASE acme.tar.gz
          rm -fr acme.tar.gz Posh-ACME
          az storage blob upload --account-name $(leconfigstorageaccount) --container config --name acme.tar.gz.gpg --file acme.tar.gz.gpg --validate-content
        azureSubscription: $(AzureSubscription)
        workingDirectory: $(Agent.TempDirectory)
      env:
        PASSPHRASE: $(symmetricKey)

    - task: AzurePowerShell@4
      condition: and(succeeded(), eq(variables['letsEncryptEnvironment'], 'LE_PROD'))
      displayName: Enable-AzFrontDoorCustomHttps
      inputs:
        azurePowerShellVersion: LatestVersion
        azureSubscription: $(azureSubscription)
        ScriptType: InlineScript
        Inline: |
          $vaultId = (Get-AzKeyVault -VaultName $(keyVaultName)).ResourceId
          Enable-AzFrontDoorCustomHttps -ResourceGroupName blog -FrontDoorName mattwhiteblog -VaultId $vaultId -SecretName mattwhiteblog -SecretVersion $(certificateVersion)
